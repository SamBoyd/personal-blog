#!/usr/bin/env python3
"""Generate a weekly feedback summary report from tagged CSV data.

Combines deterministic Python-computed sections (stats, theme table,
resolved/unresolved tracking) with narrative sections generated by the
Claude Code CLI (pain points, praise, quotes, action candidates).
"""

from __future__ import annotations

import csv
import shutil
import subprocess
import time
from collections import Counter
from datetime import datetime, timedelta
from pathlib import Path

import click


class FeedbackReportError(Exception):
    """Raised when report generation encounters an unrecoverable error."""


REQUIRED_COLUMNS = (
    "Submitted at",
    "feedback",
    "theme",
    "tags",
    "sentiment",
    "urgency",
    "repeat_signal",
)

DATE_FORMAT = "%Y-%m-%d %H:%M:%S"


def _log(verbose: bool, message: str) -> None:
    if verbose:
        click.echo(message)


def _check_claude_cli() -> str:
    """Return the path to the claude binary, or exit with an error."""
    path = shutil.which("claude")
    if path is None:
        click.echo(
            "ERROR: 'claude' CLI not found on PATH. "
            "Install Claude Code first: https://docs.anthropic.com/en/docs/claude-code",
            err=True,
        )
        raise SystemExit(1)
    return path


def _load_csv(csv_path: Path, verbose: bool) -> list[dict[str, str]]:
    """Load and validate the tagged feedback CSV."""
    if not csv_path.is_file():
        raise FeedbackReportError(f"CSV file not found: {csv_path}")

    with csv_path.open("r", encoding="utf-8", newline="") as fh:
        reader = csv.DictReader(fh)
        if reader.fieldnames is None:
            raise FeedbackReportError(f"CSV file is empty: {csv_path}")

        fieldnames = [f.strip() for f in reader.fieldnames]
        missing = [col for col in REQUIRED_COLUMNS if col not in fieldnames]
        if missing:
            raise FeedbackReportError(
                f"CSV is missing required columns: {', '.join(missing)}"
            )

        rows = []
        for row in reader:
            stripped = {k.strip(): v.strip() if v else "" for k, v in row.items()}
            rows.append(stripped)

    if not rows:
        raise FeedbackReportError(f"CSV has headers but no data rows: {csv_path}")

    return rows


def _parse_date(date_str: str) -> datetime | None:
    """Parse a date string, returning None on failure."""
    try:
        return datetime.strptime(date_str.strip(), DATE_FORMAT)
    except (ValueError, AttributeError):
        return None


def _partition_rows(
    rows: list[dict[str, str]],
    week_ending: datetime,
    verbose: bool,
) -> tuple[list[dict[str, str]], list[dict[str, str]]]:
    """Split rows into current_week and prior_weeks based on the 7-day window."""
    week_start = week_ending - timedelta(days=6)
    current_week = []
    prior_weeks = []
    skipped = 0

    for row in rows:
        dt = _parse_date(row.get("Submitted at", ""))
        if dt is None:
            skipped += 1
            continue

        if week_start <= dt <= week_ending.replace(hour=23, minute=59, second=59):
            current_week.append(row)
        else:
            prior_weeks.append(row)

    if skipped > 0:
        _log(verbose, f"Warning: skipped {skipped} rows with unparseable dates.")

    return current_week, prior_weeks


# ---------------------------------------------------------------------------
# Deterministic sections (Python-generated)
# ---------------------------------------------------------------------------


def _build_summary_stats(
    current_week: list[dict[str, str]],
    all_rows: list[dict[str, str]],
) -> str:
    """Build the Summary Stats markdown section."""
    lines = ["## Summary Stats", ""]
    lines.append(f"- **Feedback this week**: {len(current_week)}")
    lines.append(f"- **Cumulative feedback (all time)**: {len(all_rows)}")

    # Sentiment breakdown
    sentiment_counts = Counter(r.get("sentiment", "").lower() for r in current_week)
    total = len(current_week) or 1
    lines.append("")
    lines.append("**Sentiment breakdown** (this week):")
    for label in ("positive", "neutral", "negative"):
        count = sentiment_counts.get(label, 0)
        pct = count / total * 100
        lines.append(f"- {label.capitalize()}: {count} ({pct:.0f}%)")

    # Urgency distribution
    urgency_counts = Counter(r.get("urgency", "").lower() for r in current_week)
    lines.append("")
    lines.append("**Urgency distribution** (this week):")
    for label in ("high", "medium", "low"):
        count = urgency_counts.get(label, 0)
        pct = count / total * 100
        lines.append(f"- {label.capitalize()}: {count} ({pct:.0f}%)")

    return "\n".join(lines)


def _build_theme_table(current_week: list[dict[str, str]]) -> str:
    """Build the Top Themes markdown table."""
    theme_counts = Counter(r.get("theme", "unknown").strip() for r in current_week)
    total = len(current_week) or 1
    ranked = theme_counts.most_common()

    lines = ["## Top Themes", ""]
    lines.append("| Theme | Count | % |")
    lines.append("|-------|------:|--:|")
    for theme, count in ranked:
        pct = count / total * 100
        lines.append(f"| {theme} | {count} | {pct:.0f}% |")

    return "\n".join(lines)


def _build_resolved_unresolved(
    current_week: list[dict[str, str]],
    prior_weeks: list[dict[str, str]],
    week_ending: datetime,
) -> str:
    """Build the Resolved vs. Unresolved markdown section."""

    def _extract_tags(rows: list[dict[str, str]]) -> set[str]:
        tags: set[str] = set()
        for row in rows:
            raw = row.get("tags", "")
            for tag in raw.split(","):
                tag = tag.strip().lower()
                if tag:
                    tags.add(tag)
        return tags

    current_tags = _extract_tags(current_week)

    # Prior 4 weeks (28 days before current week start)
    week_start = week_ending - timedelta(days=6)
    prior_4w_start = week_start - timedelta(days=28)
    recent_prior = [
        r for r in prior_weeks
        if (dt := _parse_date(r.get("Submitted at", ""))) is not None
        and prior_4w_start <= dt < week_start
    ]
    prior_tags = _extract_tags(recent_prior)
    all_prior_tags = _extract_tags(prior_weeks)

    ongoing = sorted(current_tags & all_prior_tags)
    new_this_week = sorted(current_tags - all_prior_tags)
    potentially_resolved = sorted(prior_tags - current_tags)

    lines = ["## Resolved vs. Unresolved", ""]
    lines.append("**Ongoing** (seen this week and in prior weeks):")
    if ongoing:
        lines.append(f"- {', '.join(f'`{t}`' for t in ongoing)}")
    else:
        lines.append("- _None_")

    lines.append("")
    lines.append("**New this week** (not seen before):")
    if new_this_week:
        lines.append(f"- {', '.join(f'`{t}`' for t in new_this_week)}")
    else:
        lines.append("- _None_")

    lines.append("")
    lines.append("**Potentially resolved** (seen in prior 4 weeks but absent this week):")
    if potentially_resolved:
        lines.append(f"- {', '.join(f'`{t}`' for t in potentially_resolved)}")
    else:
        lines.append("- _None_")

    return "\n".join(lines)


# ---------------------------------------------------------------------------
# Claude-generated narrative sections
# ---------------------------------------------------------------------------

NARRATIVE_PROMPT_TEMPLATE = """\
You are generating sections of a weekly feedback report.

Here is the context:
- Week ending: {week_ending}

{summary_stats}

{theme_table}

{resolved_unresolved}

Here are all {row_count} feedback entries from this week:
{formatted_rows}

Generate exactly 4 markdown sections. Output ONLY the markdown, no preamble:

## Repeated Pain Points
Group the negative/neutral repeated feedback into meaningful clusters.
For each cluster: name the issue, list how many reports, note urgency,
and briefly explain the user impact. Prioritize high-urgency items first.

## Praise of the Week!
Select 2-3 positive feedback quotes that best highlight what users love.
Include each as a blockquote with brief context about why it matters.
If no positive feedback exists, write: "_No praise recorded this week. Keep shipping!_"

## Notable Quotes
Pick 2-3 quotes from the most impactful non-praise feedback.
One quote per major theme. Include as blockquotes with the theme labeled.

## Action Candidates
Based on the data above, recommend 3-5 concrete actions worth investigating.
Numbered list. Each item should reference the evidence (counts, urgency, tags).
Focus on highest-impact items first.
"""


def _format_rows_for_prompt(rows: list[dict[str, str]]) -> str:
    """Format current-week rows as structured text for the Claude prompt."""
    lines = []
    for i, row in enumerate(rows, 1):
        lines.append(
            f"{i}. [{row.get('sentiment', '')}] [{row.get('urgency', '')}] "
            f"[{row.get('theme', '')}] [{row.get('repeat_signal', '')}]\n"
            f"   Tags: {row.get('tags', '')}\n"
            f"   \"{row.get('feedback', '')}\""
        )
    return "\n\n".join(lines)


def _build_narrative_prompt(
    current_week: list[dict[str, str]],
    summary_stats: str,
    theme_table: str,
    resolved_unresolved: str,
    week_ending: datetime,
) -> str:
    """Build the full prompt for Claude narrative generation."""
    return NARRATIVE_PROMPT_TEMPLATE.format(
        week_ending=week_ending.strftime("%Y-%m-%d"),
        summary_stats=summary_stats,
        theme_table=theme_table,
        resolved_unresolved=resolved_unresolved,
        row_count=len(current_week),
        formatted_rows=_format_rows_for_prompt(current_week),
    )


def _invoke_claude(
    claude_bin: str,
    prompt: str,
    verbose: bool,
) -> str:
    """Call the Claude Code CLI and return the narrative markdown."""
    cmd = [claude_bin, "-p", prompt]

    _log(verbose, "Invoking Claude Code for narrative sections...")
    start = time.time()
    result = subprocess.run(cmd, capture_output=True, text=True)
    elapsed = time.time() - start

    _log(verbose, f"Claude completed in {elapsed:.1f}s (exit code {result.returncode})")

    if verbose and result.stdout:
        click.echo(f"\n--- Claude stdout ---\n{result.stdout}")
    if verbose and result.stderr:
        click.echo(f"\n--- Claude stderr ---\n{result.stderr}")

    if result.returncode != 0:
        click.echo("ERROR: Claude Code exited with a non-zero status.", err=True)
        if result.stderr:
            click.echo(result.stderr, err=True)
        raise SystemExit(1)

    return result.stdout.strip()


# ---------------------------------------------------------------------------
# Report assembly
# ---------------------------------------------------------------------------


def _assemble_report(
    week_ending: datetime,
    summary_stats: str,
    theme_table: str,
    narrative: str,
    resolved_unresolved: str,
) -> str:
    """Stitch all sections into the final markdown report."""
    now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Split narrative into sections to interleave with deterministic parts.
    # Expected narrative sections: Repeated Pain Points, Praise, Notable Quotes, Action Candidates
    # We insert resolved_unresolved before Action Candidates.
    narrative_parts = narrative.split("\n## ")
    sections_before_actions = []
    action_section = ""

    for part in narrative_parts:
        if part.startswith("Action Candidates"):
            action_section = "## " + part
        elif part.strip():
            if not part.startswith("## "):
                part = "## " + part
            sections_before_actions.append(part)

    narrative_before = "\n\n".join(sections_before_actions)
    if narrative_before and not narrative_before.startswith("## "):
        narrative_before = "## " + narrative_before

    parts = [
        f"# Weekly Feedback Summary\n\n**Week ending**: {week_ending.strftime('%Y-%m-%d')}\n**Report generated**: {now}",
        summary_stats,
        theme_table,
        narrative_before,
        resolved_unresolved,
        action_section,
    ]

    return "\n\n".join(p for p in parts if p.strip()) + "\n"


# ---------------------------------------------------------------------------
# CLI
# ---------------------------------------------------------------------------


@click.command()
@click.option(
    "--csv",
    "csv_path",
    required=True,
    type=click.Path(path_type=Path, dir_okay=False),
    help="Path to the tagged feedback CSV.",
)
@click.option(
    "--week-ending",
    "week_ending_str",
    default=None,
    help="End date of the 7-day reporting window (YYYY-MM-DD). Defaults to today.",
)
@click.option(
    "--output-dir",
    "output_dir",
    default="reports",
    type=click.Path(path_type=Path, file_okay=False),
    help="Directory for output files. Defaults to 'reports'.",
)
@click.option(
    "--dry-run",
    is_flag=True,
    default=False,
    help="Print the Claude prompt to stdout instead of executing.",
)
@click.option(
    "--verbose",
    is_flag=True,
    default=False,
    help="Print diagnostics (timing, Claude output, etc.).",
)
def cli(
    csv_path: Path,
    week_ending_str: str | None,
    output_dir: Path,
    dry_run: bool,
    verbose: bool,
) -> None:
    """Generate a weekly feedback summary report from tagged CSV data."""

    # --- parse week-ending date ---
    if week_ending_str:
        try:
            week_ending = datetime.strptime(week_ending_str, "%Y-%m-%d")
        except ValueError:
            click.echo(
                f"ERROR: Invalid --week-ending date '{week_ending_str}'. Use YYYY-MM-DD.",
                err=True,
            )
            raise SystemExit(1)
    else:
        week_ending = datetime.now().replace(hour=0, minute=0, second=0, microsecond=0)

    # --- preflight ---
    claude_bin = _check_claude_cli()

    try:
        rows = _load_csv(csv_path, verbose)
    except FeedbackReportError as e:
        click.echo(f"ERROR: {e}", err=True)
        raise SystemExit(1)

    click.echo(f"CSV: {csv_path.resolve()}")
    click.echo(f"Total rows: {len(rows)}")
    click.echo(f"Week ending: {week_ending.strftime('%Y-%m-%d')}")

    # --- partition ---
    current_week, prior_weeks = _partition_rows(rows, week_ending, verbose)

    if not current_week:
        click.echo(
            f"No feedback rows found in the 7-day window ending {week_ending.strftime('%Y-%m-%d')}.",
            err=True,
        )
        raise SystemExit(1)

    week_start = week_ending - timedelta(days=6)
    click.echo(
        f"Rows in window ({week_start.strftime('%Y-%m-%d')} to "
        f"{week_ending.strftime('%Y-%m-%d')}): {len(current_week)}"
    )

    # --- deterministic sections ---
    summary_stats = _build_summary_stats(current_week, rows)
    theme_table = _build_theme_table(current_week)
    resolved_unresolved = _build_resolved_unresolved(
        current_week, prior_weeks, week_ending
    )

    # --- narrative prompt ---
    prompt = _build_narrative_prompt(
        current_week, summary_stats, theme_table, resolved_unresolved, week_ending
    )

    if dry_run:
        click.echo("\n--- DRY RUN ---")
        click.echo(f"Command: {claude_bin} -p <prompt>")
        click.echo(f"\nPrompt:\n{prompt}")
        return

    # --- invoke Claude for narrative ---
    narrative = _invoke_claude(claude_bin, prompt, verbose)

    # --- assemble and write ---
    report = _assemble_report(
        week_ending, summary_stats, theme_table, narrative, resolved_unresolved
    )

    output_dir.mkdir(parents=True, exist_ok=True)
    output_file = output_dir / f"weekly-feedback-summary-{week_ending.strftime('%Y-%m-%d')}.md"
    output_file.write_text(report, encoding="utf-8")

    click.echo(f"\nReport written to: {output_file.resolve()}")


if __name__ == "__main__":
    cli()
